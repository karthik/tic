---
title: "Getting started with CI for R"
author: "Kirill Müller"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Kirill Müller}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Overall structure

Some sections below should be a separate vignette, with a very short summary and pointers in this "Getting started" vignette.

- Architecture and build lifecycle: In "Getting started" we only have images and flow charts
- Setup: We show how to set up a simple package check + pkgdown deployment, with links to further details
- Advanced: A full description of the DSL, with link to the "Implementation" vignette for custom steps

## Prerequisites

If you are completely unfamiliar with the term Continuous Integration (CI), we highly recommend to read the following ressources:

- https://ropensci.github.io/dev_guide/ci.html
- https://juliasilge.com/blog/beginners-guide-to-travis/
- http://mahugh.com/2016/09/02/travis-ci-for-test-automation/

Now that you know that CI can help you a lot in R package development by automatically checking your package in a clean environmnent, you might wonder what the `tic` package does do make the world even simpler.

## Scope

So, what's the advantage of using _tic_?

### CI-Agnostic workflows

What does that mean, "CI-Agnostic" and why do we need it?

You may have heard that multiple CI services exist in the wild.
Some are operating system specific (e.g. Appveyor = Windows), some only support certain languages and others cost money to be used.
What all have in common: They have their own way to specify their setup file, which is most often written in YAML and stored at the top-level directory of your repo.
This setup file controls what will be done in each run.

To give you an example how different these files can be, take a look at these two examples from [Travis](https://github.com/tidyverse/dplyr/blob/master/.travis.yml) and [Appveyor](https://github.com/tidyverse/dplyr/blob/master/appveyor.yml).
While `Travis` is the only free CI services with a stable support for R (maintained by the community, specifically by @jimhester), `Appveyor` needs custom shell scripts (e.g. `travis-tool.sh`) that do some magic in the background. 

We could list way more differences - but that's exactly the point when `tic` comes in!
Rather than using the YAML synatx of Travis or the custom shell scripts on Appveyor, `tic` enables you to specify the complete workflow of the CI build in an external file called `tic.R`.
This file is pure R code and the commands do the same on all supported CI systems.

So instead of learning how to specify one specific task on different CI platforms, the user only needs to get used to the R based approach of `tic`.

### Easier deployment

You may have heard that you can also automatically deploy files via CI system. 
This means that these tools can e.g. build your `pkgdown` site on every run and conditionally push changes to your repo.
So, you do not have to build the whole `pkgdown` site locally and then commit manually all the changed files - Travis will do it for you! 

How many R packages on Github liked the idea of having a `pkgdowm` site for their package which presents all the well-written vignettes and function documentation.
But this is only valuable if the information also reflects the most recent repo state!
To let you focus on updating the content and your functions, give the work of building and deploying the documentation to Travis. 
Travis won't forget and won't complain.

`tic` initiates the deployment in the `.travis.yml` file with the following block:

```yml
before_deploy: R -q -e 'tic::before_deploy()'
deploy:
  provider: script
  script: R -q -e 'tic::deploy()'
  on:
    branches: master
```

Let's break it down:

1. Travis executes `tic::before_deploy()` which will search for instructions regarding the `before_deploy()` stage in `tic.R`. By default this looks like

```r
if (Sys.getenv("BUILD_PKGDOWN") != "") {
  get_stage("before_deploy") %>%
    add_step(step_setup_ssh())
}
```

Essentially here the function `step_setup_ ssh()` will be called if the environment variable `"BUILD_PKGDOWN"` is set.
That is just one condition among many that you can set to run certain commands conditionally.
After the prerequisites of setting up an ssh key for the upcoming deployment has been finished, 


2. You tell Travis to use a script (provider: script) that holds the instructions for the deployment you want to do.
3. This script is calling `tic::deploy()`
4. This happens only on the `master` branch, meaning that other branches do not trigger a deploy with this setting.

What happens is now that `tic::deploy()` searches again in `tic.R` for the "deploy" stage and then runs whatever you have specified there.

By default, the following will be executed:

```r
get_stage("deploy") %>%
  add_step(step_build_pkgdown()) %>% 
  add_step(step_push_deploy())
```

First, `step_build_pkgdown()` will build your `pkgdown` site and afterwards (note the `pipe` operator), `step_push_deploy()` takes care to push the results to your repo.
By default this will be the `docs/` directory of the `master` branch.

You may optionally set the deployment to the `gh-pages` branch and then change the branch for the serving of your site in your Github repo settings to `gh-pages`.
By this you do not have all the commits from Travis in your `master` branch but your `pkgdown` site will be silently updated in the backgroud without any disturbance.
Simply set the `branch` argument to `gh-pages` and `orphan = TRUE` so that a force git push is initiated.
Now, `step_push_deploy(branch = "gh-pages", orphan = TRUE)` will deploy the resulting files of your `pkgdown` site to the 'gh-pages` branch of your repo.



- Easier deployment (why needed?)
- Consistent R-based DSL, easier local testing
- Internal: Decouple R-specific workflow from main travis-ci repo
    - Travis only installs R and system deps, _tic_ handles workflow

What's not covered yet?

- `SystemRequirements`


## Architecture

How do Travis CI, the _travis_ and _tic_ packages and `tic.R` interact?

## Build lifecycle

`after_xxx` are for notification only, failures anywhere else lead to build failures, see also https://travis-ci.org/krlmlr/ci-lifecycle/builds/397482622

- Flow chart?
- Caching in the build lifecycle
- Mapping of `tic` steps to the build lifecycle
    - figure in the middle of http://ctlente.com/en/purrr-magic/: `.travis.yml` -> `tic.R` -> code
    
## Setup

Link to motivation: "Easier deployment"

- Description of the tic.* example repos and the steps necessary to recreate them
    - Setup using _travis_
- Interaction with private environment variables
- Serializing R objects to strings

## Advanced

Link to motivation: "Run tests locally, R-based DSL"

- Meta-information: `ci()`
- Run _tic_ locally
- Troubleshooting
    - Linting `.travis.yml`
    - Debugging on Travis CI ("if you must")
